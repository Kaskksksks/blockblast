<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>BlockBlast â€” Drag to Place</title>
<style>
  :root{--bg:#0f1720;--grid:#111827;--cell:#0ea5a5;--accent:#f97316;--tray:#111827;}
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;background:var(--bg);color:#e6eef6}
  .wrap{display:flex;flex-direction:column;align-items:center;gap:12px;padding:12px;}
  #gameArea{display:grid;grid-template-columns:1fr 300px;gap:12px;max-width:1100px;width:100%;}
  #canvasWrap{background:linear-gradient(180deg,#071023,#0b1220);padding:12px;border-radius:12px;box-shadow:0 6px 18px rgba(2,6,23,.6);}
  canvas{background:var(--grid);touch-action:none;border-radius:8px;display:block}
  .sidebar{background:var(--tray);padding:12px;border-radius:10px;min-height:320px;display:flex;flex-direction:column;gap:10px;}
  .info{display:flex;justify-content:space-between;align-items:center}
  .score{font-weight:700;font-size:20px;color:var(--cell)}
  .btn{background:transparent;border:1px solid rgba(255,255,255,.06);padding:8px 10px;border-radius:8px;color:#fff}
  .tray{display:flex;flex-direction:column;gap:8px;align-items:center;padding:8px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,.02), transparent)}
  .pieceSlot{width:260px;height:76px;display:flex;align-items:center;justify-content:center;border-radius:8px;position:relative}
  .hint{font-size:12px;color:#a8b3c7;text-align:center}
  footer{font-size:13px;color:#9fb0c7;margin-top:6px;text-align:center}
  input[type="text"]{width:100%;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:#eef}
  @media(max-width:880px){
    #gameArea{grid-template-columns:1fr;align-items:center}
    .sidebar{width:100%}
    .pieceSlot{width:100%}
  }
</style>
</head>
<body>
<div class="wrap">
  <h2 style="margin:0">BlockBlast â€” drag to place</h2>
  <div id="gameArea">
    <div id="canvasWrap">
      <canvas id="gameCanvas" width="640" height="640"></canvas>
    </div>

    <div class="sidebar">
      <div class="info">
        <div>
          <div class="score">Score: <span id="score">0</span></div>
          <div style="font-size:12px;color:#9fb0c7">High: <span id="hi">0</span></div>
        </div>
        <div>
          <button id="restart" class="btn">Restart</button>
        </div>
      </div>

      <div class="tray">
        <div style="font-weight:700">Pieces (drag to grid). Tap/click piece to rotate.</div>
        <div id="pieces" style="display:flex;flex-direction:column;gap:10px"></div>
      </div>

      <div style="margin-top:6px">
        <div class="hint">Complete rows or columns to clear them. Game over when none of the pieces fit.</div>
      </div>
    </div>
  </div>

  <footer>Touch / Mouse supported â€” rotate a piece by tapping it. Enjoy! ðŸŽ®</footer>
</div>

<script>
/* BlockBlast â€” static version for GitHub Pages
 - Drag pieces from tray onto grid
 - Local high score saved to localStorage
 - Embedded tiny sound effects (base64)
*/

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
let W = canvas.width, H = canvas.height;

const GRID_SIZE = 9;
let cellSize = Math.floor(W / GRID_SIZE);
const padding = 8;
cellSize = Math.floor((W - padding*2) / GRID_SIZE);

let gridOffset = {x: padding, y: padding};
let gridPixelSize = cellSize * GRID_SIZE;

let board = Array.from({length:GRID_SIZE}, ()=>Array(GRID_SIZE).fill(0));
let score = 0;
const scoreEl = document.getElementById('score');
const hiEl = document.getElementById('hi');

const PIECE_COLORS = ['#06b6d4','#f97316','#60a5fa','#34d399','#f472b6','#f59e0b'];
const PIECES = [
  [[1]],[[1,1]],[[1,1,1]],[[1],[1]],[[1,0],[1,1]],[[1,1],[1,1]],[[1,1,1],[0,1,0]],[[1,0],[1,0],[1,1]],[[1,0],[1,1]],[[1,1,1,1]]
];

const pieceContainer = document.getElementById('pieces');
let trayPieces = [];
let dragging = null;
let animClear = [];

function randFrom(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function makePiece(){ const base = JSON.parse(JSON.stringify(randFrom(PIECES))); const color = randFrom(PIECE_COLORS); return {shape: base, color, rot:0}; }
function rotateShape(shape){ const H = shape.length, W = shape[0].length; const out = Array.from({length:W}, ()=>Array(H).fill(0)); for(let r=0;r<H;r++) for(let c=0;c<W;c++) out[c][H-1-r]=shape[r][c]; return out; }
function shapeWidth(shape){ return shape[0].length; }
function shapeHeight(shape){ return shape.length; }

function resetGame(){ board = Array.from({length:GRID_SIZE}, ()=>Array(GRID_SIZE).fill(0)); score = 0; updateScore(); spawnTray(); animClear=[]; draw(); }
function spawnTray(){ trayPieces = [makePiece(), makePiece(), makePiece()]; renderTray(); }
function renderTray(){
  pieceContainer.innerHTML='';
  trayPieces.forEach((p,i)=>{
    const slot = document.createElement('div');
    slot.className='pieceSlot'; slot.style.background='transparent'; slot.style.cursor='grab'; slot.dataset.index = i;
    const cvs = document.createElement('canvas'); cvs.width = 240; cvs.height = 76; cvs.style.touchAction='none'; slot.appendChild(cvs);
    drawPiecePreview(cvs.getContext('2d'), p);
    slot.addEventListener('pointerdown', e=>startDragFromTray(e, p, i, slot));
    slot.addEventListener('click', (ev)=>{ if(dragging && dragging.fromSlot===slot) return; p.shape = rotateShape(p.shape); drawPiecePreview(cvs.getContext('2d'), p); });
    pieceContainer.appendChild(slot);
  });
}

function drawPiecePreview(g, p){
  const Wp = g.canvas.width, Hp = g.canvas.height;
  g.clearRect(0,0,Wp,Hp);
  const s = p.shape; const h = s.length, w = s[0].length;
  const box = Math.min(Wp/w, Hp/h);
  const startX = (Wp - box*w)/2; const startY = (Hp - box*h)/2;
  g.fillStyle = p.color;
  for(let r=0;r<h;r++) for(let c=0;c<w;c++){ if(s[r][c]){ roundRect(g, startX + c*box + 2, startY + r*box + 2, box-4, box-4, 6); g.fill(); } }
}
function roundRect(g,x,y,w,h,r){ g.beginPath(); g.moveTo(x+r,y); g.arcTo(x+w,y,x+w,y+h,r); g.arcTo(x+w,y+h,x,y+h,r); g.arcTo(x,y+h,x,y,r); g.arcTo(x,y,x+w,y,r); g.closePath(); }

function startDragFromTray(e, piece, index, slotEl){
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  dragging = { piece, originalIndex: index, fromSlot: slotEl, startClientX: e.clientX, startClientY: e.clientY, offsetX: e.clientX - rect.left, offsetY: e.clientY - rect.top };
  canvas.setPointerCapture(e.pointerId);
  draw();
}

function endDrag(e){
  if(!dragging) return;
  const dropPos = getCanvasPos(e);
  const gridPos = pixelToGrid(dropPos.x - gridOffset.x, dropPos.y - gridOffset.y);
  attemptPlacePiece(dragging.piece, gridPos.r, gridPos.c);
  dragging = null;
  renderTray();
  draw();
}

function getCanvasPos(e){ const rect = canvas.getBoundingClientRect(); return {x: (e.clientX - rect.left), y: (e.clientY - rect.top)}; }

function attemptPlacePiece(piece, gridR, gridC){
  if(gridR===null || gridC===null) return;
  const s = piece.shape; const h = s.length, w = s[0].length;
  if(gridR < 0 || gridC < 0) return;
  if(gridR + h > GRID_SIZE || gridC + w > GRID_SIZE) return;
  for(let r=0;r<h;r++) for(let c=0;c<w;c++) if(s[r][c]){ if(board[gridR + r][gridC + c]) { playSound(sfx.invalid); return; } }
  for(let r=0;r<h;r++) for(let c=0;c<w;c++) if(s[r][c]){ board[gridR + r][gridC + c] = piece.color; }
  playSound(sfx.place);
  const idx = trayPieces.indexOf(piece);
  if(idx>=0){ trayPieces.splice(idx,1); trayPieces.push(makePiece()); } else { spawnTray(); }
  handleClears(); updateScore();
}

function handleClears(){
  const rowsToClear = []; const colsToClear = [];
  for(let r=0;r<GRID_SIZE;r++){ if(board[r].every(cell=>cell)) rowsToClear.push(r); }
  for(let c=0;c<GRID_SIZE;c++){ let full=true; for(let r=0;r<GRID_SIZE;r++) if(!board[r][c]) full=false; if(full) colsToClear.push(c); }
  if(rowsToClear.length===0 && colsToClear.length===0) return;
  const clearedCells = [];
  for(const r of rowsToClear) for(let c=0;c<GRID_SIZE;c++){ clearedCells.push({r,c,color:board[r][c]}); board[r][c]=0; }
  for(const c of colsToClear) for(let r=0;r<GRID_SIZE;r++){ if(!rowsToClear.includes(r)){ clearedCells.push({r,c,color:board[r][c]}); board[r][c]=0; } }
  const gain = clearedCells.length * 10; score += gain; playSound(sfx.clear); animClear.push({cells:clearedCells,frame:0});
}

function updateScore(){ scoreEl.textContent = score; const hi = Math.max(Number(localStorage.getItem('bb_high')||0), score); hiEl.textContent = hi; }

function draw(){
  ctx.fillStyle = '#071827'; ctx.fillRect(0,0,W,H);
  ctx.fillStyle = '#0b1220'; roundRect(ctx, gridOffset.x-2, gridOffset.y-2, gridPixelSize+4, gridPixelSize+4, 10); ctx.fill();
  for(let r=0;r<GRID_SIZE;r++) for(let c=0;c<GRID_SIZE;c++){
    const x = gridOffset.x + c*cellSize; const y = gridOffset.y + r*cellSize;
    ctx.fillStyle = '#06161e'; roundRect(ctx, x+4, y+4, cellSize-8, cellSize-8, 6); ctx.fill();
    const col = board[r][c];
    if(col){ ctx.fillStyle = col; roundRect(ctx, x+6, y+6, cellSize-12, cellSize-12, 6); ctx.fill(); }
  }
  ctx.strokeStyle = 'rgba(255,255,255,0.03)'; ctx.lineWidth = 1;
  for(let i=0;i<=GRID_SIZE;i++){ const px = gridOffset.x + i*cellSize; ctx.beginPath(); ctx.moveTo(px, gridOffset.y); ctx.lineTo(px, gridOffset.y+gridPixelSize); ctx.stroke(); const py = gridOffset.y + i*cellSize; ctx.beginPath(); ctx.moveTo(gridOffset.x, py); ctx.lineTo(gridOffset.x+gridPixelSize, py); ctx.stroke(); }
  if(dragging){ let pointerX = dragging.offsetX, pointerY = dragging.offsetY; if(pointerX==null){ pointerX = gridOffset.x + gridPixelSize/2; pointerY = gridOffset.y + gridPixelSize/2; } const piece = dragging.piece; drawGhostPiece(ctx, piece, pointerX, pointerY); }
  if(animClear.length>0){ const a = animClear[0]; a.frame++; const t = a.frame/20; a.cells.forEach(cell=>{ const x = gridOffset.x + cell.c*cellSize; const y = gridOffset.y + cell.r*cellSize; ctx.globalAlpha = Math.max(0,1 - t); ctx.fillStyle = cell.color || '#fff'; roundRect(ctx, x+8, y+8, cellSize-16, cellSize-16, 6); ctx.fill(); ctx.globalAlpha = 1; }); if(a.frame>20) animClear.shift(); requestAnimationFrame(draw); } else { if(checkGameOver()) drawGameOver(); }
}

function drawGhostPiece(g, piece, pointerX, pointerY){
  const localX = pointerX - gridOffset.x; const localY = pointerY - gridOffset.y; const cand = pixelToGrid(localX, localY); const s = piece.shape; const h=s.length,w=s[0].length; const snapR = cand.r, snapC = cand.c;
  const fits = (snapR>=0 && snapC>=0 && snapR+h<=GRID_SIZE && snapC+w<=GRID_SIZE) && (()=>{ for(let r=0;r<h;r++) for(let c=0;c<w;c++) if(s[r][c] && board[snapR+r][snapC+c]) return false; return true; })();
  for(let r=0;r<h;r++) for(let c=0;c<w;c++) if(s[r][c]){ const x = gridOffset.x + (snapC + c)*cellSize; const y = gridOffset.y + (snapR + r)*cellSize; g.globalAlpha = fits ? 0.95 : 0.45; g.fillStyle = piece.color; roundRect(g, x+6, y+6, cellSize-12, cellSize-12, 6); g.fill(); g.globalAlpha = 1.0; if(!fits){ g.strokeStyle='rgba(0,0,0,0.45)'; g.lineWidth=2; g.beginPath(); g.moveTo(x+10,y+10); g.lineTo(x+cellSize-10,y+cellSize-10); g.moveTo(x+cellSize-10,y+10); g.lineTo(x+10,y+cellSize-10); g.stroke(); } }
}

function pixelToGrid(px, py){ if(px < 0 || py < 0 || px >= gridPixelSize || py >= gridPixelSize) return {r:null,c:null}; const c = Math.floor(px / cellSize); const r = Math.floor(py / cellSize); return {r,c}; }

function checkGameOver(){ for(const p of trayPieces){ const h = shapeHeight(p.shape), w = shapeWidth(p.shape); for(let r=0;r<=GRID_SIZE-h;r++){ for(let c=0;c<=GRID_SIZE-w;c++){ let ok=true; for(let rr=0;rr<h;rr++) for(let cc=0;cc<w;cc++) if(p.shape[rr][cc] && board[r+rr][c+cc]) ok=false; if(ok) return false; } } } return true; }

function drawGameOver(){ ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(gridOffset.x, gridOffset.y + gridPixelSize/2 - 40, gridPixelSize, 80); ctx.fillStyle = '#fff'; ctx.font = '28px system-ui'; ctx.textAlign = 'center'; ctx.fillText('Game Over', gridOffset.x + gridPixelSize/2, gridOffset.y + gridPixelSize/2 - 4); ctx.font = '16px system-ui'; ctx.fillText('Press Restart to play again', gridOffset.x + gridPixelSize/2, gridOffset.y + gridPixelSize/2 + 20); const prev = Number(localStorage.getItem('bb_high')||0); if(score > prev) localStorage.setItem('bb_high', score); updateScore(); }

canvas.addEventListener('pointerdown', e=>{ if(!dragging) return; canvas.setPointerCapture(e.pointerId); const rect = canvas.getBoundingClientRect(); dragging.offsetX = e.clientX - rect.left; dragging.offsetY = e.clientY - rect.top; });
canvas.addEventListener('pointermove', e=>{ if(!dragging) return; const rect = canvas.getBoundingClientRect(); dragging.offsetX = e.clientX - rect.left; dragging.offsetY = e.clientY - rect.top; draw(); });
canvas.addEventListener('pointerup', e=>{ if(!dragging) return endDrag(e); });
document.addEventListener('pointerup', e=>{ if(dragging) { const rect = canvas.getBoundingClientRect(); const inside = e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom; if(inside) { endDrag(e); } else { dragging = null; draw(); } } });

// tiny base64 sounds (very short beeps)
const sfx = {
  place: new Audio("data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0YQAAAAAA/////wAAAP///wAA"),
  clear: new Audio("data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0YQAAAAAA/////wAAAP///wAA"),
  invalid: new Audio("data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0YQAAAAAA/////wAAAP///wAA")
};
function playSound(a){ try{ if(!a) return; a.currentTime=0; a.play().catch(()=>{}); }catch(e){} }

resetGame(); updateScore();

document.getElementById('restart').addEventListener('click', ()=>{ if(window.event && window.event.shiftKey){ localStorage.removeItem('bb_high'); hiEl.textContent = '0'; } resetGame(); });

function resizeCanvas(){ const wrap = canvas.parentElement; const maxW = Math.min(wrap.clientWidth - 10, window.innerWidth - 40); const size = Math.floor(Math.min(maxW, 800)); canvas.width = size; canvas.height = size; W = canvas.width; H = canvas.height; cellSize = Math.floor((W - padding*2) / GRID_SIZE); gridOffset = {x: padding, y: padding}; gridPixelSize = cellSize * GRID_SIZE; draw(); }
window.addEventListener('resize', resizeCanvas); resizeCanvas();

// helper escape (not used but safe)
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
</script>
</body>
</html>