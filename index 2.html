<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>BlockBlast — Improved</title>
<style>
  :root{--bg:#2b2f6b;--grid:#18314a;--cell:#ffd54f;--accent:#ff7043;--tray:#1f2a44;}
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;background:linear-gradient(180deg,#3b4aa1,#2b2f6b);color:#fff}
  .wrap{display:flex;flex-direction:column;align-items:center;gap:10px;padding:12px;}
  header{display:flex;align-items:center;justify-content:space-between;width:100%;max-width:980px;padding:6px 12px}
  h1{margin:0;font-size:18px;letter-spacing:0.5px}
  #gameArea{display:grid;grid-template-columns:1fr 320px;gap:14px;max-width:980px;width:100%;align-items:start;}
  #canvasWrap{background:linear-gradient(180deg,rgba(255,255,255,0.03),transparent);padding:8px;border-radius:14px;display:flex;justify-content:center;align-items:center;}
  canvas{background:linear-gradient(180deg,#081426,#0d2a3a);touch-action:none;border-radius:8px;display:block;max-width:100%}
  .sidebar{background:rgba(255,255,255,0.03);padding:12px;border-radius:12px;min-height:340px;display:flex;flex-direction:column;gap:10px;}
  .info{display:flex;justify-content:space-between;align-items:center}
  .score{font-weight:800;font-size:26px;color:var(--cell);text-align:center}
  .small{font-size:13px;color:rgba(255,255,255,0.8)}
  .btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;color:#fff}
  .tray{display:flex;flex-direction:row;gap:8px;align-items:center;padding:8px;border-radius:8px;background:transparent;justify-content:center;flex-wrap:wrap}
  .pieceSlot{width:92px;height:92px;display:flex;align-items:center;justify-content:center;border-radius:10px;position:relative;background:rgba(255,255,255,0.02);box-shadow:inset 0 1px 0 rgba(255,255,255,0.02);}
  .pieceSlot.empty{opacity:0.35;background:rgba(255,255,255,0.01);}
  .hint{font-size:12px;color:#dfe9ff;text-align:center}
  footer{font-size:13px;color:rgba(255,255,255,0.7);margin-top:6px;text-align:center}
  .leader{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;max-height:220px;overflow:auto}
  @media(max-width:900px){
    #gameArea{grid-template-columns:1fr;align-items:center}
    .sidebar{width:100%}
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>BlockBlast</h1>
    <div class="small">Drag pieces into the grid • No rotation</div>
  </header>

  <div id="gameArea">
    <div id="canvasWrap">
      <canvas id="gameCanvas" width="720" height="720" aria-label="BlockBlast game board"></canvas>
    </div>

    <div class="sidebar" role="region" aria-label="Game controls">
      <div class="info">
        <div style="text-align:left">
          <div class="small">Score</div>
          <div class="score" id="score">0</div>
        </div>
        <div style="text-align:right">
          <div class="small">High</div>
          <div class="small" id="hi">0</div>
          <div style="height:6px"></div>
          <button id="restart" class="btn">Restart</button>
        </div>
      </div>

      <div style="font-weight:700">Pieces</div>
      <div class="tray" id="pieces" aria-label="Piece tray">
        <!-- slots rendered here horizontally -->
      </div>

      <div class="hint">Use all three pieces in the tray before a new set appears. Pieces do not rotate. Tap a used slot to see it greyed out.</div>
    </div>
  </div>

  <footer>Improved layout — blocks fill the grid and scoring is applied on placement & clears.</footer>
</div>

<script>
/* Improved BlockBlast (static)
 - fixed tray behavior: 3 slots, only spawn new set after all 3 used
 - horizontal tray, consistent preview sizes
 - 8x8 grid, blocks fill grid more naturally
 - scoring: points for placement and clearance with combo bonuses
 - rotation removed
*/

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
let W = canvas.width, H = canvas.height;

// GRID changes: use 8x8 as requested
const GRID_SIZE = 8;
let padding = 6;
let cellPadding = 3; // small visual gap between cells
let cellSize = Math.floor((Math.min(W,H) - padding*2) / GRID_SIZE);
let gridOffset = {x: padding, y: padding};
let gridPixelSize = cellSize * GRID_SIZE;

// Board state: 0 or color string
let board = Array.from({length:GRID_SIZE}, ()=>Array(GRID_SIZE).fill(0));

// score
let score = 0;
const scoreEl = document.getElementById('score');
const hiEl = document.getElementById('hi');

// pieces and tray
const PIECE_COLORS = ['#ffd54f','#ff7043','#66bb6a','#42a5f5','#ab47bc','#ef5350'];
const PIECES = [
  [[1]],[[1,1]],[[1,1,1]],[[1],[1]],[[1,0],[1,1]],[[1,1],[1,1]],[[1,1,1],[0,1,0]],[[1,0],[1,0],[1,1]],[[1,0],[1,1]],[[1,1,1,1]]
];

const pieceContainer = document.getElementById('pieces');
let trayPieces = []; // exactly 3 slots; a slot may be null when used
let dragging = null;
let animClear = [];

function randFrom(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function makePiece(){ const base = JSON.parse(JSON.stringify(randFrom(PIECES))); const color = randFrom(PIECE_COLORS); return {shape: base, color}; }
function rotateShape(shape){ /* rotation disabled by request */ return shape; }
function shapeWidth(shape){ return shape[0].length; }
function shapeHeight(shape){ return shape.length; }

// spawn a full set of 3 pieces (only called when all three used)
function spawnTray(){
  trayPieces = [makePiece(), makePiece(), makePiece()];
  renderTray();
}

// render tray horizontally with uniform preview canvases (92x92)
function renderTray(){
  pieceContainer.innerHTML='';
  for(let i=0;i<3;i++){
    const p = trayPieces[i];
    const slot = document.createElement('div');
    slot.className = 'pieceSlot' + (p? '' : ' empty');
    slot.dataset.index = i;
    // preview canvas
    const cvs = document.createElement('canvas');
    cvs.width = 88; cvs.height = 88;
    cvs.style.width = '88px'; cvs.style.height = '88px';
    slot.appendChild(cvs);
    if(p){
      drawPiecePreview(cvs.getContext('2d'), p);
      slot.style.cursor = 'grab';
      slot.addEventListener('pointerdown', e=> startDragFromTray(e,p,i,slot));
      // rotation disabled: no click rotation
    } else {
      // empty used slot: show faded placeholder
      const g = cvs.getContext('2d');
      g.clearRect(0,0,cvs.width,cvs.height);
      g.fillStyle = 'rgba(255,255,255,0.02)';
      g.fillRect(6,6,cvs.width-12,cvs.height-12);
      g.font = '12px system-ui';
      g.fillStyle = 'rgba(255,255,255,0.35)';
      g.textAlign = 'center';
      g.fillText('Used', cvs.width/2, cvs.height/2 + 4);
    }
    pieceContainer.appendChild(slot);
  }
}

// draw piece to preview canvas with uniform scaling
function drawPiecePreview(g, p){
  const Wp = g.canvas.width, Hp = g.canvas.height;
  g.clearRect(0,0,Wp,Hp);
  const s = p.shape;
  const h = s.length, w = s[0].length;
  // compute box that fits within canvas with small margin
  const margin = 12;
  const box = Math.floor((Math.min(Wp, Hp) - margin) / Math.max(w, h));
  const startX = Math.floor((Wp - box*w) / 2);
  const startY = Math.floor((Hp - box*h) / 2);
  for(let r=0;r<h;r++) for(let c=0;c<w;c++){
    if(s[r][c]){
      const x = startX + c*box, y = startY + r*box;
      roundRect(g, x+2, y+2, box-4, box-4, Math.max(2, Math.floor(box/6)));
      g.fillStyle = p.color;
      g.fill();
    }
  }
}

function roundRect(g,x,y,w,h,r){ g.beginPath(); g.moveTo(x+r,y); g.arcTo(x+w,y,x+w,y+h,r); g.arcTo(x+w,y+h,x,y+h,r); g.arcTo(x,y+h,x,y,r); g.arcTo(x,y,x+w,y,r); g.closePath(); }

// drag start
function startDragFromTray(e, piece, index, slotEl){
  if(!piece) return;
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  dragging = {
    piece,
    originalIndex: index,
    fromSlot: slotEl,
    offsetX: e.clientX - rect.left,
    offsetY: e.clientY - rect.top
  };
  canvas.setPointerCapture(e.pointerId);
  draw();
}

// drag end (drop)
function endDrag(e){
  if(!dragging) return;
  const dropPos = getCanvasPos(e);
  const gridPos = pixelToGrid(dropPos.x - gridOffset.x, dropPos.y - gridOffset.y);
  const placed = attemptPlacePiece(dragging.piece, gridPos.r, gridPos.c);
  // if placed successfully, mark tray slot as used (null)
  if(placed){
    const idx = dragging.originalIndex;
    if(typeof idx === 'number') {
      trayPieces[idx] = null;
      renderTray();
      // if all slots used, spawn new set after short delay
      if(trayPieces.every(s=>s===null)){
        setTimeout(()=>{ spawnTray(); }, 220);
      }
    }
  }
  dragging = null;
  draw();
}

// get canvas pos from pointer event
function getCanvasPos(e){
  const rect = canvas.getBoundingClientRect();
  return {x: (e.clientX - rect.left), y: (e.clientY - rect.top)};
}

// attempt to place piece at grid cell (top-left)
function attemptPlacePiece(piece, gridR, gridC){
  if(gridR===null || gridC===null) return false;
  const s = piece.shape;
  const h = s.length, w = s[0].length;
  if(gridR < 0 || gridC < 0) return false;
  if(gridR + h > GRID_SIZE || gridC + w > GRID_SIZE) return false;
  // collision
  for(let r=0;r<h;r++) for(let c=0;c<w;c++) if(s[r][c]){
    if(board[gridR + r][gridC + c]) return false;
  }
  // place and count placed cells
  let placedCount = 0;
  for(let r=0;r<h;r++) for(let c=0;c<w;c++) if(s[r][c]){
    board[gridR + r][gridC + c] = piece.color;
    placedCount++;
  }
  // scoring: reward for placement (per cell)
  const placePointsPerCell = 10;
  score += placedCount * placePointsPerCell;

  playSound(sfx.place);
  handleClears(); // may add more score
  updateScore();
  return true;
}

// handle row/col clears
function handleClears(){
  const rowsToClear = [];
  const colsToClear = [];
  for(let r=0;r<GRID_SIZE;r++){
    if(board[r].every(cell=>cell)) rowsToClear.push(r);
  }
  for(let c=0;c<GRID_SIZE;c++){
    let full=true;
    for(let r=0;r<GRID_SIZE;r++) if(!board[r][c]) full=false;
    if(full) colsToClear.push(c);
  }
  if(rowsToClear.length===0 && colsToClear.length===0) return;
  const clearedCells = [];
  for(const r of rowsToClear) for(let c=0;c<GRID_SIZE;c++){ clearedCells.push({r,c,color:board[r][c]}); board[r][c]=0; }
  for(const c of colsToClear) for(let r=0;r<GRID_SIZE;r++){
    if(!rowsToClear.includes(r)){
      clearedCells.push({r,c,color:board[r][c]}); board[r][c]=0;
    }
  }
  // scoring for clears:
  // - base per cleared cell: 50
  // - combo bonus for clearing multiple lines at once: 200 per extra line beyond the first
  const L = clearedCells.length;
  const linesCount = rowsToClear.length + colsToClear.length;
  const basePerCell = 50;
  let gain = L * basePerCell;
  if(linesCount > 1) gain += (linesCount - 1) * 200;
  score += gain;
  playSound(sfx.clear);
  animClear.push({cells: clearedCells, frame:0});
}

// update score display and local high
function updateScore(){ scoreEl.textContent = score; const prev = Number(localStorage.getItem('bb_high') || 0); if(score > prev){ localStorage.setItem('bb_high', score); } hiEl.textContent = Math.max(prev, score); }

// drawing
function draw(){
  ctx.fillStyle = '#071827';
  ctx.fillRect(0,0,W,H);

  // center grid in canvas
  // recompute grid metrics each draw (in case of resize)
  gridPixelSize = cellSize * GRID_SIZE;
  const startX = Math.floor((W - gridPixelSize)/2);
  const startY = Math.floor((H - gridPixelSize)/2);
  gridOffset.x = startX; gridOffset.y = startY;

  // grid background
  ctx.fillStyle = '#062033';
  roundRect(ctx, gridOffset.x-4, gridOffset.y-4, gridPixelSize+8, gridPixelSize+8, 10);
  ctx.fill();

  // draw cells (no large inner padding so blocks fill nicely)
  for(let r=0;r<GRID_SIZE;r++) for(let c=0;c<GRID_SIZE;c++){
    const x = gridOffset.x + c*cellSize;
    const y = gridOffset.y + r*cellSize;
    // draw cell background
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    ctx.fillRect(x+1, y+1, cellSize-2, cellSize-2);
    const col = board[r][c];
    if(col){
      ctx.fillStyle = col;
      roundRect(ctx, x+cellPadding, y+cellPadding, cellSize - cellPadding*2, cellSize - cellPadding*2, Math.max(2, Math.floor((cellSize-cellPadding*2)/6)));
      ctx.fill();
    }
  }

  // grid lines (subtle)
  ctx.strokeStyle = 'rgba(255,255,255,0.03)';
  ctx.lineWidth = 1;
  for(let i=0;i<=GRID_SIZE;i++){
    const px = gridOffset.x + i*cellSize;
    ctx.beginPath(); ctx.moveTo(px, gridOffset.y); ctx.lineTo(px, gridOffset.y+gridPixelSize); ctx.stroke();
    const py = gridOffset.y + i*cellSize;
    ctx.beginPath(); ctx.moveTo(gridOffset.x, py); ctx.lineTo(gridOffset.x+gridPixelSize, py); ctx.stroke();
  }

  // draw dragging ghost (snap to grid)
  if(dragging){
    const piece = dragging.piece;
    const localX = dragging.offsetX - gridOffset.x;
    const localY = dragging.offsetY - gridOffset.y;
    const cand = pixelToGrid(localX, localY);
    const s = piece.shape;
    const h = s.length, w = s[0].length;
    const snapR = cand.r, snapC = cand.c;
    const fits = (snapR>=0 && snapC>=0 && snapR+h<=GRID_SIZE && snapC+w<=GRID_SIZE) &&
      (()=>{ for(let r=0;r<h;r++) for(let c=0;c<w;c++) if(s[r][c] && board[snapR+r][snapC+c]) return false; return true; })();
    for(let r=0;r<h;r++) for(let c=0;c<w;c++) if(s[r][c]){
      const x = gridOffset.x + (snapC + c)*cellSize;
      const y = gridOffset.y + (snapR + r)*cellSize;
      ctx.globalAlpha = fits ? 0.9 : 0.45;
      ctx.fillStyle = piece.color;
      roundRect(ctx, x+cellPadding, y+cellPadding, cellSize - cellPadding*2, cellSize - cellPadding*2, Math.max(2, Math.floor((cellSize-cellPadding*2)/6)));
      ctx.fill();
      ctx.globalAlpha = 1.0;
      if(!fits){
        ctx.strokeStyle = 'rgba(0,0,0,0.45)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x+6,y+6); ctx.lineTo(x+cellSize-6,y+cellSize-6);
        ctx.moveTo(x+cellSize-6,y+6); ctx.lineTo(x+6,y+cellSize-6);
        ctx.stroke();
      }
    }
  }

  // animations for clears
  if(animClear.length > 0){
    const a = animClear[0];
    a.frame++;
    const t = a.frame / 24;
    a.cells.forEach(cell => {
      const x = gridOffset.x + cell.c*cellSize;
      const y = gridOffset.y + cell.r*cellSize;
      ctx.globalAlpha = Math.max(0, 1 - t);
      ctx.fillStyle = cell.color || '#fff';
      roundRect(ctx, x + cellPadding + 4, y + cellPadding + 4, cellSize - (cellPadding+4)*2, cellSize - (cellPadding+4)*2, 6);
      ctx.fill();
      ctx.globalAlpha = 1;
    });
    if(a.frame > 24) animClear.shift();
    requestAnimationFrame(draw);
  } else {
    if(checkGameOver()) drawGameOver();
  }
}

function pixelToGrid(px, py){
  if(px < 0 || py < 0 || px >= gridPixelSize || py >= gridPixelSize) return {r:null,c:null};
  const c = Math.floor(px / cellSize);
  const r = Math.floor(py / cellSize);
  return {r,c};
}

// check if any existing tray piece can be placed anywhere
function checkGameOver(){
  for(const p of trayPieces){
    if(!p) continue;
    const h = shapeHeight(p.shape), w = shapeWidth(p.shape);
    for(let r=0;r<=GRID_SIZE-h;r++){
      for(let c=0;c<=GRID_SIZE-w;c++){
        let ok=true;
        for(let rr=0;rr<h;rr++) for(let cc=0;cc<w;cc++) if(p.shape[rr][cc] && board[r+rr][c+cc]) ok=false;
        if(ok) return false;
      }
    }
  }
  return true;
}

function drawGameOver(){
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(gridOffset.x, gridOffset.y + gridPixelSize/2 - 40, gridPixelSize, 80);
  ctx.fillStyle = '#fff'; ctx.font = '28px system-ui'; ctx.textAlign = 'center';
  ctx.fillText('Game Over', gridOffset.x + gridPixelSize/2, gridOffset.y + gridPixelSize/2 - 4);
  ctx.font = '16px system-ui';
  ctx.fillText('Press Restart to play again', gridOffset.x + gridPixelSize/2, gridOffset.y + gridPixelSize/2 + 20);
  // save local high score
  const prev = Number(localStorage.getItem('bb_high')||0);
  if(score > prev) localStorage.setItem('bb_high', score);
  updateScore();
}

// pointer handlers for drag
canvas.addEventListener('pointerdown', e=>{
  if(!dragging) return;
  canvas.setPointerCapture(e.pointerId);
  const rect = canvas.getBoundingClientRect();
  dragging.offsetX = e.clientX - rect.left;
  dragging.offsetY = e.clientY - rect.top;
});

canvas.addEventListener('pointermove', e=>{
  if(!dragging) return;
  const rect = canvas.getBoundingClientRect();
  dragging.offsetX = e.clientX - rect.left;
  dragging.offsetY = e.clientY - rect.top;
  draw();
});

canvas.addEventListener('pointerup', e=>{
  if(!dragging) return endDrag(e);
});

document.addEventListener('pointerup', e=>{
  if(dragging){
    const rect = canvas.getBoundingClientRect();
    const inside = e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom;
    if(inside) endDrag(e);
    else { dragging = null; draw(); }
  }
});

// sounds (tiny embedded)
const sfx = {
  place: new Audio("data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0YQAAAAAA/////wAAAP///wAA"),
  clear: new Audio("data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0YQAAAAAA/////wAAAP///wAA"),
  invalid: new Audio("data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0YQAAAAAA/////wAAAP///wAA")
};
function playSound(a){ try{ if(!a) return; a.currentTime = 0; a.play().catch(()=>{}); }catch(e){} }

// initial setup
function resetGame(){
  board = Array.from({length:GRID_SIZE}, ()=>Array(GRID_SIZE).fill(0));
  score = 0;
  updateScore();
  spawnTray();
  animClear = [];
  draw();
}

document.getElementById('restart').addEventListener('click', ()=>{
  // reset high if shift-click (desktop)
  if(window.event && window.event.shiftKey){ localStorage.removeItem('bb_high'); hiEl.textContent = '0'; }
  resetGame();
});

function resizeCanvas(){
  const wrap = canvas.parentElement;
  const maxW = Math.min(wrap.clientWidth - 20, window.innerWidth - 40);
  const size = Math.floor(Math.min(720, maxW));
  canvas.width = size; canvas.height = size;
  W = canvas.width; H = canvas.height;
  cellSize = Math.floor((Math.min(W,H) - padding*2) / GRID_SIZE);
  gridOffset = {x: Math.floor((W - cellSize*GRID_SIZE)/2), y: Math.floor((H - cellSize*GRID_SIZE)/2)};
  gridPixelSize = cellSize * GRID_SIZE;
  draw();
}
window.addEventListener('resize', resizeCanvas);

// helper
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

// initial run
resetGame();
updateScore();
resizeCanvas();

</script>
</body>
</html>
